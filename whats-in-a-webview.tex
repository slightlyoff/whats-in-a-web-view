\documentclass[sigconf]{acmart}

\usepackage[utf8]{inputenc}
% \usepackage[hyphens]{url}
% \usepackage[pdftex,urlcolor=black,colorlinks=true,linkcolor=black,citecolor=black]{hyperref}
% \def\sectionautorefname{Section}
% \def\subsectionautorefname{Subsection}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{textcomp}
\usepackage{gensymb}
\usepackage[super]{nth}

\usepackage{listings}
\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, then, catch, switch, var, const, let, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstset{
   language=JavaScript,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   captionpos=b
}

% todo macro
\usepackage{color}
\newcommand{\todo}[1]{\noindent\textcolor{red}{{\bf \{TODO}: #1{\bf \}}}}

\settopmatter{printacmref=false}

% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[WOODSTOCK'97]{ACM Woodstock conference}{July 1997}{El
  Paso, Texas USA}
\acmYear{1997}
\copyrightyear{2016}

\acmArticle{4}
\acmPrice{15.00}

% These commands are optional
%\acmBooktitle{Transactions of the ACM Woodstock conference}
%\ editor{Jennifer B. Sartor}
% \editor{Theo D'Hondt}
% \editor{Wolfgang De Meuter}


\begin{document}
\title[What is in a~Web View?]{What is in a~Web View?
An Analysis of Progressive Web App Features
When the Means of Web Access is not a~Web Browser}  

% \titlenote{}
% \subtitle{}
% \subtitlenote{}


\author{Thomas Steiner}
% \authornote{}
% \orcid{1234-5678-9012}
\affiliation{%
  \institution{Google Germany GmbH}
  \streetaddress{ABC-Straße 19}
  \city{20354 Hamburg}
  \country{Germany}
}
\email{tomac@google.com}

\author{Michael Yeung}
% \authornote{}
% \orcid{1234-5678-9012}
\affiliation{%
  \institution{Google Hong Kong}
  \streetaddress{1~Matheson Street}
  \city{Causeway Bay}
  \country{Hong Kong}
}
\email{micyeung@google.com}

% The default list of authors is too long for headers.
%\renewcommand{\shortauthors}{B. Trovato et al.}

\begin{abstract}
Progressive Web Apps (\textsc{pwa}) are a~new class of Web applications,
enabled for the most part by the Service Workers \textsc{api}s.
Service Workers allow apps to \emph{work offline}
by intercepting network requests to deliver programmatic or cached responses,
Service Workers can receive \emph{push notifications}
and \emph{synchronize} data in the background
even when the app is not running,
and---together with Web App Manifests---allow users to \emph{install \textsc{pwa}s}
to their devices' home screens.
Service Workers being a Web standard, support has landed in several
stand-alone Web browsers---among them (but not limited to)
Chrome and its open-source foundation Chromium, Firefox, Edge, Opera,
\textsc{uc}~Browser, Samsung Internet, as well as preview versions of Safari.
In this paper, we examine the \textsc{pwa} feature support situation in \emph{Web Views},
that is,\ \emph{in-app Web experiences} that are explicitly \emph{not} stand-alone browsers.
Such in-app browsers can commonly be encountered in chat applications like WeChat or WhatsApp,
online social networks like Facebook or Twitter, but also email clients like Gmail,
or simply anywhere where Web content is displayed inside native apps.
We have developed an open-source application called \emph{\textsc{pwa} Feature Detector}
that allows for easily testing in-app browsers (and naturally stand-alone browsers as well)
and have evaluated the level of support for \textsc{pwa} features
on different devices and Web Views.
On the one hand, our results show that there are big differences
between the various Web View technologies
and the browser engines they are based upon,
but on the other hand, that the results
are independent from the devices' operating systems,
which is good news given the problematic update policy of many device manufacturers.
These findings help developers make educated choices when it comes to determining
whether a~\textsc{pwa} is the right approach given their target users' means of Web access.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%

\keywords{Progressive Web Apps, Service Workers, Web Views}

\maketitle

\section{Introduction}

In recent years, there has been a~paradigm shift
from browser to native apps and back to browser again.
The Web currently is undergoing a silent revolution with Web apps,
more descriptively \emph{Progressive Web Apps},
or for short just \textsc{pwa}s.
How did we get there?

\subsection{History of Progressive Web Apps}

Since around 2005, Web development has moved from static multi-page \emph{documents}
to single-page \emph{applications}, heavily enabled by the \texttt{XMLHttpRequest} \textsc{api},
a~process that eventually led Garrett to coin the term \emph{Ajax}
(Asynchronous JavaScript and XML~\cite{garret2005ajax}) to describe this shift.
Despite an early push for Web-based apps on devices such as the 2007 iPhone,
attempts at Web apps mostly failed by comparison to native apps
that were distributed through app stores rather than the Web.
Native apps not only had direct hardware access to, \emph{e.g.},\ camera and microphone,
to various sensors like accelerometer or geolocation, but also just in general provided
a~better user experience and booted faster compared to having to load in a~browser at runtime.
Additionally, advanced offline support and push notifications were simply unthinkable
for Web applications at the time, and Web app icons
that already could be added to devices' home screens
were mostly just bookmarks with---apart from full screen mode---no special behavior.
While straightforward offline scenarios could be realized with
\texttt{AppCache}~\cite{vankesteren2008offlinewebapps}, more complex offline scenarios were error-prone
and hard to get right~\cite{archibald2012douchebag}.

As the Web platform matured and more and more
hardware-related \textsc{api}s were implemented in browsers,
in the end it was the addition of Service Workers~\cite{russell2017serviceworkers}
to the Chromium browser in 2014~\cite{cooney2014chromium} that started to unlock a~new class of Web apps
that finally could \emph{work offline}, receive \emph{push notifications}
and \emph{synchronize} data in the background even when the app was not running,
and---together with Web App Manifests~\cite{caceres2017manifest}---allowed
users to actually \emph{install \textsc{pwa}s} to their devices' home screens
with proper operating system integration~\cite{kinlan2017a2hs}.
Other browsers like Mozilla Firefox, Microsoft Edge, Opera, \textsc{uc}~Browser, Samsung Internet,
Apple Safari Technology Preview, and several browsers more followed in implementing Service Workers.
Now, even multinational companies like Twitter
or trivago bet on \textsc{pwa}~\cite{gallagher2017twitterlite,twg2017trivago},
as well as giant national players like Tencent News or Sina Weibo in China~\cite{zhu2017pwa}.
\autoref{fig:pwa-features} shows the \textsc{pwa} of Flipkart, a~shopping site popular in India,
running in the Google Chrome browser on Android.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=\columnwidth]{pwa-features}
  \caption[Screenshots showing some \textsc{pwa} features]{
    Screenshots showing some \textsc{pwa} features at the example of Flipkart (\url{https://www.flipkart.com/}):
    \emph{(i)} add to home screen prompt, \emph{(ii)} icon on home screen
    \emph{(iii)} splash screen while launching, \emph{(iv)} launched in full screen (no address bar),
    \emph{(v)} signaling offline state.}
  \label{fig:pwa-features}
\end{figure}

\subsection{Research Question and Paper Structure}

In this paper, we look at a~special means for accessing \textsc{pwa}s,
namely accessing them \emph{not} through stand-alone browsers like the ones listed above,
but through \emph{in-app browsers} that render Web content in the context of native applications.
Examples of such applications with in-app browsers are chat apps like WeChat (Wēixìn) or WhatsApp,
online social networks like Facebook or Twitter, but also email clients like Gmail.
The technology that these applications leverage internally are so-called \emph{Web Views}.
In order to understand why this presents an interesting research problem,
one needs to first understand the role that applications like WeChat play in markets like China.
Chan writes in an article~\cite{chan2015wechat} for the venture capital firm Andreessen Horowitz:
``Millions (note, not just thousands) of lightweight apps live inside WeChat,
much like webpages live on the internet.
\emph{This makes WeChat more like a~browser for mobile websites}, or, arguably,
a~mobile operating system---complete with its own proprietary app store.
The lightweight apps on WeChat are called `official accounts'.
Approved by WeChat after a~brief application process,
there are well over 10 million of these official accounts on the platform---ranging
from celebrities, banks, media outlets, and fashion brands to hospitals, drug stores,
car manufacturers, internet startups, personal blogs, and more''.
Chan goes on: ``WeChat focuses on taking care of the plumbing---overseeing
the integration of such pre-existing services into its portal---by
simply linking users from the wallet menu to webpages from within the app.
It's yet another way in which \emph{WeChat
becomes an integrated browser for the mobile (and web) world}''.
It is to be noted that this development comes to the detriment of the so-called open Web.
As Yang and Yang write in the Financial Times~\cite{yang2017tencent}:
``[WeChat's] news feed and search tools pull content only from within WeChat's walls
rather than from the open web, including updates posted by individual users called moments,
corporate accounts and an immense collection of WeChat accounts
which are used by newspapers and independent bloggers''.
While personally we are advocates of the open Web,
we therefore examine the implications of an in-app closed Web experience
and what this means for \textsc{pwa}. 

In the remainder of this paper, we first look at the technical background of Web Views
and describe the \textsc{pwa} features and their underlying \textsc{api}s in \autoref{sec:background},
introduce our application \emph{\textsc{pwa} Feature Detector} in \autoref{sec:pwa-feature-detector},
and present and discuss our results in \autoref{sec:results-and-discussion}.
We close the paper with an outlook on future work in \autoref{sec:future-work}
and draw some conclusions in \autoref{sec:conclusions}.

\section{Background on Web Views}
\label{sec:background}

There are many different ways to integrate Web content in native applications,
each having their own benefits and drawbacks.
In the following, we describe the options on the two popular
mobile operating system Android and i\textsc{os}.
At time of writing, Safari on i\textsc{os} does not support Service Workers yet.
For the sake of completeness, we nevertheless describe the Web View situation there as well.

\subsection{Web Views on Android}

\paragraph{Android Web Views with \texttt{WebView}}

In the Android operating system, a~\texttt{WebView}~\cite{android2018webview}
is a~subclass of a~\texttt{View} that displays Web pages.
This class is the basis upon which developers can create their own Web browser
or simply display some online content in their apps.
It does not include any features of a~fully developed Web browser,
such as navigation controls or an address bar.
All that \texttt{WebView} does, by default, is show a~Web page.
Therefore, it uses the system browser's rendering engine to display Web pages
and includes methods to navigate forward and backward through a history,
zoom in and out, perform text searches and more.
Looper describes~\cite{looper2015webviews}
the development of the component as follows:
``Whereas earlier versions of the Android \textsc{os}
relied on the WebKit rendering engine to power its \texttt{WebView},
as of Android~4.4, various versions of Chromium are implemented.
Typically, with each consecutive update of Android's \texttt{os},
a~new version of Chromium would also be included, thereby giving access
to the new rendering engine's capability.
This causes issues in backward compatibility for developers
who must support earlier versions of Android.
To combat this particular problem, as of Android~5.0,
the concept of the auto-updating \texttt{WebView} has been introduced.
Instead of the \texttt{WebView} version and capabilities
depending on Android \textsc{os}' update cycle,
the Android~5.0 \texttt{WebView} is a~system-level \texttt{.apk} file
available in Google Play that can update itself in the background''.

\paragraph{Chrome Custom Tab with \texttt{CustomTabsIntent}}

While \texttt{WebView}s are completely isolated from the user's regular browsing activities,
Chrome Custom Tabs~\cite{kinlan2016customtabs}, available since Chrome~45 (September 2015)
and instantiatable as \texttt{CustomTabsIntent}, provide a~way for an application
to customize and interact with a~Chrome Activity on Android.
This makes the Web content feel like being a part of the application,
while retaining the full functionality and performance of a~complete Web browser
through a~shared cookie jar and permissions model, so users do not have to log in
to sites they are already connected to, or re-grant permissions they have already granted.

\paragraph{Trusted Web Activity with \texttt{TwaSessionHelper}}

Chrome Custom Tabs solved many issues of Android Web Views,
however, had the drawback of not being available in a~fullscreen variant like Web Views.
As of October 2017, Trusted Web Activities~\cite{googledevelopers2017twa} are a~new way to
integrate Web app content such as \textsc{pwa}s with Android apps.
They can be instantiated with a~\texttt{TwaSessionHelper}
and use a~protocol based on Chrome Custom Tabs.
Content in a~Trusted Web Activity is trusted---the app and the site it opens
are expected to come from the same developer, this is verified using Digital Asset
Links.\footnote{Digital Asset Links:
\url{https://developers.google.com/digital-asset-links/}}
The host app does not have direct access to Web content in a~Trusted Web Activity
or any other kind of Web state.
Transitions between Web and native content are between activities.
Each activity (\emph{i.e.},\ screen) of an app is either completely provided by the Web,
or by an Android activity.
While not enforced at time of writing, Trusted Web Activities
will ultimately need to meet content requirements
similar to the ``improved add to home screen`` flow~\cite{kinlan2017a2hs},
which is designed to be a~baseline of interactivity and performance.

\subsection{Web Views on i\textsc{os}}

\paragraph{i\textsc{os} Web Views with \texttt{UIWebView}}

Similar to Android, on i\textsc{os} as well Web content could be embedded with
a~simple system-level Web View called \texttt{UIWebView}.\footnote{\texttt{UIWebView}:
\url{https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIWebView_Class/}}
With the release of i\textsc{os}~4.3 in early 2011, Apple introduced Nitro,
a~faster, just-in-time (\textsc{jit}) JavaScript engine for Safari
that considerably sped up the browser's performance in loading complex Web pages.
Nitro was exclusive to Safari: third-party developers could not benefit
from the faster performance in their Web views based on \texttt{UIWebView},
which was widely considered a~calculated move to encourage usage of Safari
over Web Views and Web apps saved to the iPhone's home screen~\cite{viticci2015safari}.

\paragraph{i\textsc{os} Web Views with \texttt{WKWebView}}

In June 2014, Apple announced \texttt{WKWebView},\footnote{\texttt{WKWebView}:
\url{https://developer.apple.com/library/ios/documentation/WebKit/Reference/WKWebView_Ref/}}
a~new API that would allow developers
to display Web content in custom Web Views with the same performance benefits of Safari.
Designed with security in mind, \texttt{WKWebView} featured the same Nitro engine of Safari,
while still allowing developers to customize the experience
with their own user interface and features.
Due to Apple's App Store restrictions, third-party browsers on i\textsc{os}
internally need to depend on \texttt{WKWebView}, documented,
\emph{e.g.},\ for Edge for i\textsc{os}~\cite{lyndersay2017edge}
or Chrome for i\textsc{os}~\cite{chromiumblog2016chrome}.

\paragraph{i\textsc{os} Web Views with \texttt{SFSafariViewController}}

In September 2015 with the release of i\textsc{os}~9, Apple introduced a~new Web View called
\texttt{SFSafariViewController}\footnote{\texttt{SFSafariViewController}:
\url{https://developer.apple.com/documentation/safariservices/sfsafariviewcontroller}},
which enables apps to delegate the responsibility of showing Web content to Safari itself,
avoiding the need to write custom code for built-in browsers.
Up until i\textsc{os}~10, Safari View Controller shared cookies and website data with Safari,
which means that if a~user was already logged into a~specific website in Safari
and a~link to that website was opened in Safari View Controller,
the user was already logged in.
As of i\textsc{os}~11, cookie and website data is no longer shared,
but developers can leverage
an \texttt{SFAuthenticationSession}\footnote{\texttt{SFAuthenticationSession}:
\url{https://developer.apple.com/documentation/safariservices/sfauthenticationsession}}
that shares data upon user consent. 

\subsection{Parallelisms on the Two Operating Systems}

The development on the two operating systems has certain parallels
that can be summarized as follows.
From the initially slow and gradually improved simple Web Views \texttt{WebView}
(with the transparent internal switch from WebKit to Chromium)
on Android and \texttt{UIWebView} and \texttt{WKWebView} on i\textsc{os},
there was an evolution to more powerful and better integrated browser tab experiences,
namely \texttt{CustomTabsIntent} on Android and
\texttt{SFSafariViewController} on i\textsc{os},
which both (only upon user consent since i\textsc{os}~11)
share cookies, permissions, \emph{etc.}
with the particular system's main browser.
Android's \texttt{TwaSessionHelper} so far has no i\textsc{os} equivalent yet.

\section{Detecting \textsc{pwa} Features}
\label{sec:pwa-feature-detector}

What exactly makes a~Web app a~\emph{Progressive} Web App is not clearly defined.
One of the most open definitions comes from Samsung~\cite{samsung2017pwa},
maker of the Samsung Internet browser:
``Progressive Web Apps (\textsc{pwa}s) are regular mobile and desktop web applications
that are accessible in any web browser.
In browsers that support new open web standards [\ldots]
they \emph{can} provide additional capabilities
including offline support and push notifications'' (emphasis ours).
However, just like with Ajax~\cite{garret2005ajax}, the term \textsc{pwa}
became a~catch-all umbrella brand for Web apps
that in some way or the other use Service Worker \textsc{api}s,
feel (native) ``app-like,'' use latest browser features if they are available
(Progressive Enhancement~\cite{champeon2003progressiveenhancement}),
or that can be installed (added) to the home screen.
Russell~\cite{russell2016pwa} lists a~number of requirements 
for what he calls ``baseline appyness'':
``A~Progressive Web App is functionally defined by the technical properties
that allow the browser to detect that the site meets certain criteria
and is worthy of being added to the homescreen.
These criteria are motivated by user-experience concerns.
Apps on the homescreen:

\begin{itemize}
  \item Should load instantly, regardless of network state.
    [T]hey [don't] need to function fully offline,
    but they must put their own UI on screen without requiring a network round trip.
  \item Should be tied in the user's mind to where they came from.
    The brand or site behind the app shouldn't be a mystery.
  \item Can run without extra browser chrome (\emph{e.g.},\ the \textsc{url} bar).
    [\ldots] To prevent hijacking by captive portals (and worse),
    apps must be loaded over \textsc{tls} connections.''
\end{itemize}

In continuation, Russell translates these requirements into more technical terms,
writing that \textsc{pwa}s must:

\begin{itemize}
  \item ``Originate from a Secure Origin.
    Served over \textsc{tls} and green padlock displays (no active mixed content).
  \item Load while offline (even if only a custom offline page).
    By implication, this means that Progressive Web Apps require Service Workers.
  \item Reference a~Web App Manifest [\ldots]''
\end{itemize}

For our study, we consider a~``\textsc{pwa} feature'' any feature that requires 
one or more of the Service Worker \textsc{api}s.
Additionally, if (if and only if) the Web View implements Service Workers,
we consider some more recent browser \textsc{api}s,
detailed in the following.

\subsection{Progressive Web App Features}

A~\texttt{ServiceWorker} is installed by calling the registration method
on the \texttt{navigator} object, the first parameter is obligatory
and contains a~\textsc{url} that points to a~JavaScript file with the Service Worker logic.
The result of this promise-based \textsc{api} in the success case is then
a~\texttt{ServiceWorkerRegistration} object,
which is either newly created if there was no previous \texttt{ServiceWorker},
or updated in the alternative case
where a~previous \texttt{ServiceWorker} existed~\cite{russell2017serviceworkers}.
In order to detect if a~given Web View supports \textsc{pwa} features at all,
we can thus make a simple existence check for the \textsc{api},
and then try to register a~Service Worker, as outlined in \autoref{code:sw-supported}.
If the Web View supports Service Workers, we look at the following \textsc{pwa} features.

\begin{lstlisting}[caption={Checking for Service Worker support.},
  label=code:sw-supported, language=JavaScript, float=htb] 
  if ('serviceWorker' in navigator) { 
    navigator.serviceWorker.register(scriptURL, options)
    .then(registration => {
      console.log(registration);
    })
    .catch(error => {
      console.log(error);
    });
  } else {
    console.log('Service Workers not supported');
  }
\end{lstlisting}

\begin{description}
  \itemsep0em 
  \item[Offline Capabilities] The ability to still load and work
    at least to some extent, even when the device is offline, for example,
    when it is in airplane mode or currently has no network~\cite{russell2017serviceworkers}.
  \item[Push Notifications] The capability to display push notifications as defined in
    the Push \textsc{api}~\cite{beverloo2017pushapi}, for example,
    to point users to fresh content, even when the app is not running.
  \item[Add to Home Screen] The capability to be installed (added) to a~device's home screen
    for easy access as outlined in~\cite{kinlan2017a2hs}.
  \item[Background Sync] The capability to synchronize data in the background,
    for example, to send messages in a~deferred way
    after an offline situation in a~chat app~\cite{russell2017serviceworkers}.
  \item[Navigation Preload] The capability to start network navigation requests
    even while the Service Worker has not booted yet~\cite{archibald2017navigationpreload},
    which would else be a~blocking operation.
  \item[Silent Push] The capability to use the Web Budget \cite{beverloo2017budgetapi}
    in order to determine if potentially expensive operations should be started
    following a~silent push notification.
  \item[Storage Estimation] The capability to estimate the available storage
    an application already uses and the available quota enforced by the
    browser~\cite{vankesteren2018storage}.
  \item[Persistent Storage] The capability to persistently store data
    that is guaranteed not to be purged by the browser without user consent,
    even if memory is running out~\cite{vankesteren2018storage}.
  \item[Web Share] The capability to invoke the native sharing widgets
    of the browser, as defined in the Web Share \textsc{api}~\cite{giuca2017webshare}.
  \item[Media Session] The capability to show customized media metadata
    on the platform user interface, customize available platform media controls,
    and access platform media keys found in notification areas
    and on lock screens of mobile devices
    as defined in the Media Session standard~\cite{lamouri2017mediasessionapi}.
  \item[Media Capabilities] The ability to make an optimal decision
    when picking media content for the user by exposing information
    about the decoding and encoding capabilities for a given format,
    but also output capabilities to find the best match based on the device's display
    as defined in Media Capabilities standard~\cite{lamouri2017mediacapabilities}.
  \item[Device Memory] The capability to read the amount of available
    Random Access Memory (\textsc{ram}) in Gigabyte
    of a~device in order to allow servers to customize the app experience
    based on the available memory~\cite{panicker2017devicememory}.
  \item[Getting Installed Related Apps] The capability to detect if a~corresponding
    native application is installed alongside the \textsc{pwa} in order to,
    for example, not show push notifications twice on both apps~\cite{kinlan2017relatedapps}.
  \item[Payment Request] The capability to act as intermediary among merchants,
    users, and payment methods by means of a~standardized payment communication flow
    that supports different secure payment methods~\cite{bateman2017paymentrequest}.
  \item[Credential Management] The capability to request a user's credentials
    from the browser, and to help the browser correctly store user credentials
    for future use~\cite{west2017credentialmanagement}.
\end{description} 

\subsection{Feature-Detecting Various \textsc{pwa} Features}

A~core principle of Progressive Enhancement~\cite{champeon2003progressiveenhancement}
is \emph{feature detection}.
The idea behind feature detection is to run a~test to determine
whether a~certain feature is supported in the current browser,
and then conditionally run code to provide an acceptable experience
both in browsers that do support the feature, and browser that do not.
It is distinct from \emph{browser sniffing}, where based on the user agent string
assumptions are being made regarding feature support,
which is generally considered problematic and bad practice~\cite{andersen2008useragent}.
\autoref{code:feature-detection} shows the feature detection tests
we run in order to detect the features listed in the previous subsection.
As outlined before, a \texttt{ServiceWorkerRegistration},
\emph{i.e.},\ an active Service Worker is a~prerequisite for all tests.  
The variables \texttt{nav} for \texttt{navigator},
\texttt{win} for \texttt{window}, and \texttt{doc} for \texttt{document}
purely serve for code minification.

\begin{lstlisting}[caption={Feature detection of various \textsc{pwa} features.},
  label=code:feature-detection, language=JavaScript, float=htb] 
  // nav ==> navigator
  // win ==> window
  // doc ==> document
  // reg ==> ServiceWorkerRegistration
  const detectFeatures = (reg) => {
    return {
      'Offline Capabilities': 'caches' in win,
      'Push Notifications': 'pushManager' in reg,
      'Add to Home Screen': doc.createElement('link')
          .relList.supports('manifest'),
      'Background Sync': 'sync' in reg,
      'Navigation Preload': 'navigationPreload' in reg,
      'Silent Push': 'budget' in nav &&
          'reserve' in nav.budget,
      'Storage Estimation': 'storage' in nav &&
          'estimate' in nav.storage,
      'Persistent Storage': 'storage' in nav &&
          'persist' in nav.storage,
      'Web Share': 'share' in nav,
      'Media Session': 'mediaSession' in nav,
      'Media Capabilities': 'mediaCapabilities' in nav,
      'Device Memory': 'deviceMemory' in nav,
      'Getting Installed Related Apps':
          'getInstalledRelatedApps' in nav,
      'Payment Request': 'PaymentRequest' in win,
      'Credential Management': 'credentials' in nav,
    };
  };    
\end{lstlisting}  

\subsection{Implementation Details}

We have developed an open-source application called \emph{\textsc{pwa} Feature Detector}
that allows for easily testing in-app browsers (and obviously stand-alone browsers on top)
and check for the available \textsc{pwa} features.
The code of the application can be found at
\url{https://github.com/tomayac/pwa-feature-detector},
the app itself is deployed at \url{https://tomayac.github.io/pwa-feature-detector/}.
\autoref{fig:wechat-android-chrome65} shows a~screenshot of \textsc{pwa} Feature Detector
running on Android~8.1.99 in WeChat in a~Web View based on Chrome~65.

\begin{figure}[hbt]
  \centering
  \includegraphics[width=\columnwidth,frame]{pwa-feature-detector-wechat-android-chrome65}
  \caption[\textsc{pwa} Feature Detector running in WeChat.]{
    \textsc{pwa} Feature Detector running on Android~8.1.99 in WeChat
    in a~\texttt{WebView} based on Chrome~65.}
  \label{fig:wechat-android-chrome65}
\end{figure}

\begin{figure}[hbt]
  \centering
  \includegraphics[width=\columnwidth,frame]{pwa-feature-detector-twitter-android-chrome65}
  \caption[\textsc{pwa} Feature Detector running in Twitter.]{
    \textsc{pwa} Feature Detector running on Android~8.1.99 in Twitter
    in a~\texttt{CustomTabsIntent} based on Chrome~65.}
  \label{fig:wechat-android-chrome65}
\end{figure}

\section{Results and Discussion}
\label{sec:results-and-discussion}

We have 

Table \ref{table:webview}
Table \ref{table:customtab}

\begin{figure*}[htb]
  \setcounter{figure}{0}
  \renewcommand{\figurename}{Table}
  \begin{center}
  \centerline{\includegraphics[trim=1.5cm 22.75cm 1.5cm 1.5cm, clip]{webview-results.pdf}}
  % https://docs.google.com/spreadsheets/d/18xaJeIrfaA-8wNucK7IDQMfr5LHjsBcey4lHF3Pkd1o/edit?usp=sharing
  \caption{Increasingly improving \textsc{pwa} feature support situation
    on various Android \texttt{WebView}s, ordered by browser engine and Android version.
    The sole \emph{seemingly} supported Web Share feature in Chrome~61
    was actually a bug (\url{https://crbug.com/765923}).}
  \label{table:webview}
  \end{center}
\end{figure*}

\begin{figure}[htb]
  \renewcommand{\figurename}{Table}
  \begin{center}
  \centerline{\includegraphics[width=.65\columnwidth,trim=4.3cm 16.25cm 4.3cm 1.5cm, clip]{custom-tab-results.pdf}}
  % https://docs.google.com/spreadsheets/d/18xaJeIrfaA-8wNucK7IDQMfr5LHjsBcey4lHF3Pkd1o/edit?usp=sharing
  \caption{Increasingly improving \textsc{pwa} feature support situation
    on various Android \texttt{CustomTabsIntent}s,
    ordered by browser engine and Android version.}
  \label{table:customtab}
  \end{center}
\end{figure}

\begin{figure*}[htb]
  \begin{center}
  \centerline{\includegraphics[trim=.5cm 13.75cm .5cm .5cm, clip]{index-sheet.pdf}}
  \caption{Index sheet with all tested device screenshots showing both \texttt{WebView}s
    and \texttt{CustomTabsIntent}s running in different applications.
    High-resolution screenshots available at \url{https://photos.app.goo.gl/FdRsGOgtgNfvRIKB2}.}
  \label{fig:indexsheet}
  \end{center}
\end{figure*}

\section{Future Work}
\label{sec:future-work}

\section{Conclusions}
\label{sec:conclusions}


\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}

\end{document}
